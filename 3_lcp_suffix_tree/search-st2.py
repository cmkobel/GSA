# Author: Carl M. Kobel 2019

# Write a program, search-st2, where you have replaced the suffix tree construction algorithm that you wrote in the previous project with the new construction algorithm, i.e. constructs the suffix tree from the LCP and suffix arrays as generated by gen-lcp.
# The program, search-st2, should support both generating and serialising a suffix tree and search for reads using it.
# If search-st2 is called with the option -p, it should take an additional argument that should be a FASTA file. In this case, it creates files that can be used to rebuild the suffix trees of the strings contained in the FASTA file in linear time.
# For searching, the search-st2 program should take the same input and produce the same output as in all the previous projects.

import gen_lcp
from trienode import trienode # for making a tree in linear time from sa and lcp-a


# Setup
S = 'Mississippi'
S = 'sassasass'

#S = S.replace(' ', '')

suffixes, sa, lcp = list(zip(*gen_lcp.lcp(S)))
n = len(S)
lcp = [i for i in lcp] + [lcp[-1]] # Måske ville det være smartere at duplikere den sidste værdi, fordi så skal der ikke splittes på nogen måde ahead of time.

root = trienode('', '')


print('i\t\tsa\tlcp\tsuffixes\n~~~~+~~~~~~~~~~~~~~~~')

parent_stack = []
# Iterating over each suffix, being able to look around in sa and lcp.
for i, suffix in enumerate(suffixes):
    print(i, '|', sa[i], lcp[i], suffixes[i], '\t\t',parent_stack, sep = '\t')
    


    # Case 0: lcp is zero.
    if lcp[i] == 0:
        #print(' inserting at root')


        parent_stack = [root]

        new_node = trienode(suffix, suffix)
        
        parent_stack[-1].adopt(new_node)
        parent_stack.append(new_node)
        
    # Case 1: lcp has increased.
    elif i > 0 and lcp[i] > lcp[i-1]: # lcp has increased
        parent_stack[-1].split(lcp[i]-lcp[i-1])
        

        new_node = trienode(suffix[lcp[i]:], parent_stack[-1].string_label + suffix[lcp[i]:])
        parent_stack[-1].adopt(new_node)
        
        if lcp[i+1] > lcp[i]: # because the next suffix has a larger lcp, we know that it is going to be appended to this new node.
            parent_stack.append(new_node)

    # Case 2: lcp is the same.
    elif lcp[i] == lcp[i-1]: # lcp is the same, append to the same parent.
        new_node = trienode(suffix[lcp[i]:], parent_stack[-1].string_label + suffix[lcp[i]:])
        parent_stack[-1].adopt(new_node)

        if lcp[i+1] > lcp[i]: # because the next suffix has a larger lcp, we know that it is going to be appended to this new node.

            parent_stack.append(new_node)
        # Do not change parents.

    # Case 3: lcp is lower.
    
    elif i > 0 and lcp[i] < lcp[i-1]:
        # Gå op igennem forældrestakken indtil der findes en forælder der skal splittes.

        backtraced_letters = 0 # Jeg tror ikke backtraced_letters skal stå her, den skal jo kun nulstilles hvis vi er i roden?
        #for parent in reversed(parent_stack): # Man burde sige for i in range(len(parent_stack)), og så poppe en parent, og bruge den som parent.
        #for _unused in range(len(parent_stack)):
        while len(parent_stack) > 0:
            parent = parent_stack.pop() # Man kunne sikker også lave en pytonisk iterator som bruger pop til at loope igennem bagfra. 
            # måske burde man poppe i bunden.

            
            backtraced_letters += len(parent.in_edge_label) # Tæl længden af hver parent op.
            print(' iterated parent:', parent, parent.in_edge_label, ' backtraced_letters:', backtraced_letters)

            # In this case, a single level up is necessary, so it is hard to test that the code is working properly, anyway..:

            # Hvis backtraced_letters indeholder den forskel der er mellem lcp[i-1] og lcp[i], ved vi, at vi er gået langt nok op.
            if backtraced_letters >= lcp[i-1]-lcp[i]:

                print('  splitting parent at:', len(parent.in_edge_label) - (lcp[i-1]-lcp[i]))
                print('  difference:', lcp[i-1] - lcp[i])

                split_point = backtraced_letters - (lcp[i-1]-lcp[i])
                print('  split_point:', split_point)

                parent.split(split_point)
                print('  Just did a split. Current parent is:', parent_stack[-1], 'with children:', parent_stack[-1].children)
                #print('  Just did a split. Current parent is:', parent, 'with children:', parent.children)

                #parent.split(len(parent.in_edge_label) - lcp[i-1]+lcp[i]) # Før jeg vidste at jeg prøvede at splitte noget der ikke skal splittes, og begyndte at undre mig over hvorfor den ikke rammer nul når noden allerede er splittet, brugte jeg denne linje (backup).


                new_node = trienode(suffix[lcp[i]:], parent.string_label + suffix[lcp[i]:])
                print('  This is the node that is going to be adopted', new_node)
                print('  with suffix:', parent.string_label + suffix[lcp[i]:])
                # split skal beholde current til den gamle
                parent.adopt(new_node)


                if lcp[i+1] > lcp[i]: # because the next suffix has a larger lcp, we know that it is going to be appended to this new node.
                    parent_stack.append(new_node)
                    #print(parent_stack) # 1) Så nu er vi på ssippi$. Hvordan ved vi hvordan vi skal splitte den til den næste?


                break # stop her

                # Because backtraced letters is bigger than what we need, we need to split the middle of the node.
            #parent_stack.pop()





    root.visualize(f'iter/{i} {suffix}')

root.visualize(f'iter/Done')




